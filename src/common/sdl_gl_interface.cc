#include <SDL/SDL_opengl.h>

#include "sdl_gl_interface.h"
#include "utilities.h"
#include "exceptions.h"

//////////////////////////////////////////////////////////////////////////////////
// Function definitions for SDL_GL_Window:
//////////////////////////////////////////////////////////////////////////////////

SDL_GL_Window::SDL_GL_Window( const int w, const int h, const int bpp, const Uint32 flags, const std::string &title ) :
    screen_( 0 ),
    screen_width_( w ), 
    screen_height_( h ), 
    screen_bpp_( bpp ),
    sdl_video_flags_( flags ),
    title_( title )
{
}

void SDL_GL_Window::initGL()
{
    glEnable( GL_DEPTH_TEST );
    glEnable( GL_BLEND );
    glEnable( GL_TEXTURE_2D );

    glClearColor( 1.0f, 0.0f, 1.0f, 1.0f );
    glClearDepth( 1.0f );
    glDepthFunc( GL_LEQUAL );
    glShadeModel( GL_SMOOTH );
    glHint( GL_PERSPECTIVE_CORRECTION_HINT, GL_NICEST );
    glBlendFunc( GL_SRC_ALPHA, GL_ONE_MINUS_SRC_ALPHA );
}

void SDL_GL_Window::createWindow()
{
    bool ok = false;

    if( SDL_Init( SDL_INIT_VIDEO ) != -1 )
    {
        // TODO: Check return values here, and verify that they have not changed after the SDL_SetVideoMode() call.
        SDL_GL_SetAttribute( SDL_GL_RED_SIZE, 8 );
        SDL_GL_SetAttribute( SDL_GL_GREEN_SIZE, 8 );
        SDL_GL_SetAttribute( SDL_GL_BLUE_SIZE, 8 );
        SDL_GL_SetAttribute( SDL_GL_ALPHA_SIZE, 8 );
        SDL_GL_SetAttribute( SDL_GL_DEPTH_SIZE, 16 );
        SDL_GL_SetAttribute( SDL_GL_DOUBLEBUFFER, 1 );

        // SDL_GL_SetAttribute( SDL_GL_MULTISAMPLEBUFFERS, 1 ); // TODO: Doesn't seem to work.
        // SDL_GL_SetAttribute( SDL_GL_MULTISAMPLESAMPLES, 4 );

        if( ( screen_ = SDL_SetVideoMode( screen_width_, screen_height_, screen_bpp_, sdl_video_flags_ ) ) )
        {
            // Warp the mouse and then purge the event queue to hide the SDL_MOUSE_MOTION event generated by the warp.
            // TODO: Clean this up!!
            // SDL_WarpMouse( 0, 0 );
            // processEvents( false );
            // processEvents( false );
            // processEvents( false );

            SDL_WM_SetCaption( title_.c_str(), NULL );
            SDL_FillRect( screen_, NULL, SDL_MapRGBA( screen_->format, 0, 0, 0, 0 ) );
        
            initGL();
            reshapeWindow();
            ok = true;
        }
        else VNOTIFY( FAULT, "SDL_SetVideoMode() failed: %s", SDL_GetError() );
    }
    else VNOTIFY( FAULT, "SDL_Init() failed: %s", SDL_GetError() );

    if ( !ok ) throw LoadingError( "Error creating SDL window." );
}

void SDL_GL_Window::reshapeWindow( const int w, const int h )
{
    screen_width_ = w;
    screen_height_ = h;

    reshapeWindow();
}

void SDL_GL_Window::reshapeWindow()
{
    glViewport( 0, 0,( GLsizei )( screen_width_ ), ( GLsizei )( screen_height_ ) );

    glMatrixMode( GL_PROJECTION );
    glLoadIdentity();
    gluPerspective( 45.0f, ( GLfloat )( screen_width_ ) / ( GLfloat )( screen_height_ ), 1.0f, 1000.0f );

    glMatrixMode( GL_MODELVIEW );
    glLoadIdentity();
}

//////////////////////////////////////////////////////////////////////////////////
// Function definitions for SDL_GL_Interface:
//////////////////////////////////////////////////////////////////////////////////

SDL_GL_Interface::SDL_GL_Interface( SDL_GL_Window &window, const int fps_limit ) :
    run_( false ),
    fps_limit_( fps_limit ),
    window_( window )
{
    window_.createWindow();
}

SDL_GL_Interface::~SDL_GL_Interface()
{
    SDL_Quit();
}

void SDL_GL_Interface::toggleFullscreen()
{
    SDL_Surface* s = SDL_GetVideoSurface();

    if( !s || ( SDL_WM_ToggleFullScreen( s ) != 1 ) )
    {
        VNOTIFY( FAULT, "Unable to toggle fullscreen: %s", SDL_GetError() );
    }
}

void SDL_GL_Interface::processEvents( const bool doHandle )
{
    SDL_Event event;

    while( SDL_PollEvent( &event ) ) if ( doHandle ) handleEvent( event );
}

void SDL_GL_Interface::handleEvent( SDL_Event &event )
{
    switch ( event.type )
    {
        case SDL_KEYDOWN:
            //handleKeyDownEvent( event.key.keysym.sym, event.key.keysym.mod );
            handleKeyDownEvent( event );
            break;

        case SDL_KEYUP:
            //handleKeyUpEvent( event.key.keysym.sym, event.key.keysym.mod );
            handleKeyUpEvent( event );
            break;

        case SDL_MOUSEMOTION:
            //handleMouseMotionEvent( event.button.button, event.motion.x, event.motion.y, event.motion.xrel, event.motion.yrel );
            handleMouseMotionEvent( event );
            break;

        case SDL_MOUSEBUTTONDOWN:
            //handleMouseDownEvent( event.button.button, event.motion.x, event.motion.y, event.motion.xrel, event.motion.yrel );
            handleMouseDownEvent( event );
            break;

        case SDL_MOUSEBUTTONUP:
            //handleMouseUpEvent( event.button.button, event.motion.x, event.motion.y, event.motion.xrel, event.motion.yrel );
            handleMouseUpEvent( event );
            break;
    
        case SDL_VIDEORESIZE:
            window_.reshapeWindow( event.resize.w, event.resize.h );
            break;
    
        case SDL_QUIT:
            run_ = false;
            break;
    }
}

void SDL_GL_Interface::mainLoop()
{
    run_ = true;

    last_step_time_ = SDL_GetTicks();

    while ( run_ )
    {
        long current_time = SDL_GetTicks();
        long step_time = current_time - last_step_time_;
        double 
            step_time_seconds = step_time * 0.001,
            fps = 1.0 / step_time_seconds;

        if ( ( fps_limit_ == 0 && step_time > 0 ) || fps <= fps_limit_ )
        {
            last_step_time_ = current_time;
            
            processEvents( true );
            doOneStep( step_time_seconds );
            
            glClear( GL_COLOR_BUFFER_BIT | GL_DEPTH_BUFFER_BIT );
            glMatrixMode( GL_MODELVIEW );
            glLoadIdentity();
            draw();
            glFlush();
            SDL_GL_SwapBuffers();
        }
    }
}
